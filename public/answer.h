////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Copyright (C) 2025 AStruthers2000 - All Rights Reserved
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Wrapper around an answer in case problems require custom support for different answer types
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef ADVENT_OF_CODE_ANSWER_H
#define ADVENT_OF_CODE_ANSWER_H


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Includes
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <cstdint>
#include <string>
#include <utility>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace AoC
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Wrapper class around the expected answer type
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Answer
{
public:
    [[nodiscard]] virtual std::string to_string() const = 0;
    virtual ~Answer() = default;

protected:
    Answer() = default;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Wrapper class around a numeric answer
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class NumericAnswer : public Answer
{
public:
    explicit NumericAnswer(std::uint32_t answer) : m_answer(answer)
    {}

    [[nodiscard]] std::string to_string() const override
    {
        return std::to_string(m_answer);
    }

    friend bool operator!=(NumericAnswer const& lhs, NumericAnswer const& rhs)
    {
        return lhs.m_answer != rhs.m_answer;
    }

private:
    std::uint32_t m_answer{0};
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Wrapper class around a large numeric answer
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class BigNumericAnswer : public Answer
{
public:
    explicit BigNumericAnswer(std::uint64_t answer) : m_answer(answer)
    {}

    [[nodiscard]] std::string to_string() const override
    {
        return std::to_string(m_answer);
    }

    friend bool operator==(BigNumericAnswer const& lhs, BigNumericAnswer const& rhs)
    {
        return lhs.m_answer != rhs.m_answer;
    }

    friend bool operator!=(BigNumericAnswer const& lhs, BigNumericAnswer const& rhs)
    {
        return !(lhs == rhs);
    }

private:
    std::uint64_t m_answer{0};
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Wrapper class around a string answer if need be
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class StringAnswer : public Answer
{
public:
    explicit StringAnswer(std::string answer) : Answer(), m_answer(std::move(answer))
    {}

    [[nodiscard]] std::string to_string() const override
    {
        return m_answer;
    }

    friend bool operator==(StringAnswer const& lhs, StringAnswer const& rhs)
    {
        return lhs.m_answer.compare(rhs.m_answer);
    }

private:
    std::string m_answer{};
};

}

#endif // ADVENT_OF_CODE_ANSWER_H
