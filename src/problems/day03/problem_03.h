////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Copyright (C) 2025 AStruthers2000 - All Rights Reserved
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Header for problem 03 implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef ADVENT_OF_CODE_PROBLEM_03_H
#define ADVENT_OF_CODE_PROBLEM_03_H

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Includes
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "problem.h"

import aoc.grid;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Namespace
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace AoC
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @brief Problem 03 concrete implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Problem03 : public Problem
{

public:
    /**
     * @brief Constructor that passes and automatically loads file data
     * @param [in] input_data_path Path to this problem's data file
     */
    explicit Problem03(std::string_view input_data_path) : Problem(input_data_path, true)
    {}

    /**
     * @brief Loads the problem data into a problem-specific format
     * @return True if loading was successful, false otherwise
     */
     bool load_problem() override;

    /**
     * @brief Solves part 1 of day 03
     * @return Returns an Answer, or nullptr if no answer is computed yet
     */
    std::unique_ptr<Answer> solve_part_1() override;

    /**
     * @brief Solves part 2 of day 03
     * @return Returns an Answer, or nullptr if no answer is computed yet
     */
    std::unique_ptr<Answer> solve_part_2() override;

private:
    Grid::Grid2D<std::uint8_t> m_banks;

    std::uint64_t find_max_sequence(std::vector<std::uint8_t> const& row, std::size_t sequence_size) const;
    std::pair<std::uint8_t, std::size_t> find_next_greedy(std::vector<std::uint8_t> const& row, std::size_t start_pos, std::size_t max_end) const;
};

} // namespace AoC

#endif // ADVENT_OF_CODE_PROBLEM_03_H
